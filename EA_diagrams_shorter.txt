================================================================================
                    HOUSEMATE SYSTEM - UML DIAGRAMS (CONDENSED)
                         Enterprise Architecture Diagrams
================================================================================

This document contains the most important UML diagrams for the HouseMate System.
Maximum 3 diagrams per type, selected for core functionality coverage.

================================================================================
                           PART I: BEHAVIORAL DIAGRAMS
================================================================================

================================================================================
1. USE CASE DIAGRAM
================================================================================

Description: Shows the functional requirements of the HouseMate system from the
perspective of different user types (actors) and their interactions with system
features.

ACTORS:
--------
1. Guest (Unauthenticated User)
2. User (Standard authenticated user)
3. Premium User (Authenticated user with premium subscription)
4. System (Automated processes)

USE CASES BY ACTOR:

Guest:
------
- UC01: Register Account
- UC02: Login to System
- UC03: View Public Information

User (includes all Guest use cases):
------------------------------------
Authentication & Profile:
- UC04: Logout
- UC05: View Profile
- UC06: Update Profile
- UC07: Join Group (via invite code)
- UC08: View Group Members
- UC09: View Leaderboard

Task Management:
- UC10: View Tasks (Today/Overdue/Upcoming)
- UC11: Create Task
- UC12: Edit Task
- UC13: Complete Task
- UC14: Delete Task
- UC15: Filter Tasks by Date
- UC16: View Tasks in Calendar

Competition & Gamification:
- UC17: View Competitions
- UC18: Join Competition
- UC19: Leave Competition
- UC20: View Competition Leaderboard
- UC21: Track Progress in Competition
- UC22: Earn Points

Shopping & Lists:
- UC23: View Shopping Lists
- UC24: Create Shopping List
- UC25: Add Items to Shopping List
- UC26: Check Off Items
- UC27: Delete Shopping List

Recipe Management:
- UC28: View Recipes
- UC29: Search Recipes
- UC30: View Recipe Details
- UC31: Create Recipe
- UC32: Edit Recipe
- UC33: Delete Recipe

Meal Planning:
- UC34: View Meal Plans
- UC35: View Today's Meals
- UC36: Create Meal Plan
- UC37: Add Meals to Plan
- UC38: Delete Meal Plan

Product Management:
- UC39: View Products
- UC40: Search Products
- UC41: View Product by Category
- UC42: Create Product
- UC43: Upload Product Images

Project Management:
- UC44: View Projects
- UC45: Create Project
- UC46: Assign Tasks to Project
- UC47: Delete Project

Feedback:
- UC48: Submit Feedback
- UC49: View Feedback

Premium User (includes all User use cases):
-------------------------------------------
- UC50: Create Group
- UC51: Regenerate Group Invite Code
- UC52: Remove Group Member
- UC53: Create Competition
- UC54: Start Competition
- UC55: Complete Competition
- UC56: Cancel Competition

System (Automated):
-------------------
- UC57: Validate JWT Token
- UC58: Refresh Token
- UC59: Update Competition Status
- UC60: Calculate Points

RELATIONSHIPS:
--------------
- UC02 <<include>> UC57 (Login includes token validation)
- UC11 <<extend>> UC22 (Creating task may extend to earning points when completed)
- UC18 <<include>> UC21 (Joining competition includes progress tracking)
- UC53 <<extend>> UC54 (Creating competition may extend to starting it)
- User <<generalization>> Guest
- Premium User <<generalization>> User

DIAGRAM NOTATION:
-----------------
+------------------------------------------------------------------+
|                        HouseMate System                           |
|                                                                   |
|   [Guest]-----(UC01: Register)                                   |
|      |                                                            |
|      +--------(UC02: Login)----<<include>>----(UC57: Validate)   |
|                                                                   |
|   [User]------(UC10: View Tasks)                                 |
|      |                                                            |
|      +--------(UC11: Create Task)----<<extend>>--(UC22: Earn Pts)|
|      |                                                            |
|      +--------(UC17: View Competitions)                          |
|      |                                                            |
|      +--------(UC18: Join Competition)                           |
|      |                                                            |
|      +--------(UC23: View Shopping Lists)                        |
|                                                                   |
|   [Premium User]---(UC50: Create Group)                          |
|        |                                                          |
|        +-----------(UC53: Create Competition)                    |
|        |                                                          |
|        +-----------(UC54: Start Competition)                     |
|                                                                   |
|   [System]---------(UC57: Validate JWT Token)                    |
|        |                                                          |
|        +-----------(UC59: Update Competition Status)             |
+------------------------------------------------------------------+


================================================================================
2. ACTIVITY DIAGRAMS (3 Most Important)
================================================================================

--------------------------------------------------------------------------------
ACTIVITY DIAGRAM 1. User Authentication Flow
--------------------------------------------------------------------------------

@startuml Authentication_Flow
skinparam defaultFontSize 11
skinparam activityFontSize 11
skinparam arrowFontSize 10
scale 1400 width
start
:User opens app;

if (Has stored token?) then (yes)
  :Retrieve token from secure storage;
  :Send token to Auth Service for validation;

  if (Token valid?) then (yes)
    :Load user profile;
    :Navigate to Home Screen;
  else (no)
    if (Has refresh token?) then (yes)
      :Send refresh token request;
      if (Refresh successful?) then (yes)
        :Store new tokens;
        :Load user profile;
        :Navigate to Home Screen;
      else (no)
        :Clear stored credentials;
        :Show Login Screen;
      endif
    else (no)
      :Show Login Screen;
    endif
  endif
else (no)
  :Show Login Screen;
endif

fork
  :User enters credentials;
  :Submit login request;
fork end

:Auth Service validates credentials;

if (Credentials valid?) then (yes)
  :Generate JWT access token;
  :Generate refresh token;
  :Return tokens to client;
  :Store tokens in secure storage;
  :Load user profile;
  :Navigate to Home Screen;
else (no)
  :Return error message;
  :Display error to user;
endif

stop
@enduml

FLOW DESCRIPTION:
1. App startup checks for stored authentication token
2. If token exists, validates with Auth Service
3. If valid, loads user profile and navigates to Home
4. If invalid, attempts token refresh
5. If refresh fails or no token, shows Login screen
6. User submits credentials
7. Auth Service validates and returns JWT tokens
8. Tokens stored securely, user navigated to Home

--------------------------------------------------------------------------------
ACTIVITY DIAGRAM 2. Task Completion and Points Earning
--------------------------------------------------------------------------------

@startuml Task_Completion_Flow
skinparam defaultFontSize 11
skinparam activityFontSize 11
skinparam arrowFontSize 10
scale 1400 width
start
:User views task list;
:User selects task to complete;
:Toggle task 'done' status;

:Send update request to Task Service;

fork
  :Task Service updates task in Database;
fork again
  :Calculate points for completion;
fork end

:Database Service updates task record;
:Retrieve points value from task;

if (User in active competition?) then (yes)
  :Update competition progress;
  :Competition Service updates participant score;
endif

:Update user's total points score;
:Database Service updates user record;

:Return success response;
:Update UI to show completed task;
:Display points earned notification;

stop
@enduml

FLOW DESCRIPTION:
1. User views their task list (filtered by date)
2. User marks a task as completed
3. System updates task status in database
4. System calculates points earned
5. If user is in active competition, updates competition progress
6. Updates user's total point score
7. UI reflects completed task and shows points notification

--------------------------------------------------------------------------------
ACTIVITY DIAGRAM 3. Competition Lifecycle
--------------------------------------------------------------------------------

@startuml Competition_Lifecycle_Flow
skinparam defaultFontSize 11
skinparam activityFontSize 11
skinparam arrowFontSize 10
scale 1400 width
|#LightBlue|Premium User Actions
start
:Create competition;

:Enter competition details;
note right
  - Name & Description
  - Competition Type (Points/Tasks/Custom)
  - Target Value
  - Start & End Dates
  - Group Assignment
end note

:Submit competition creation;
:Competition Service creates record;
:Set status to PENDING;
:Return to competition list;

:Start competition;
:Set status to ACTIVE;
:Notify group members;

|#LightGreen|User Actions
:Users join competition;

while (Competition active?) is (yes)
  fork
    :Complete tasks;
    :Update participant progress;
  fork again
    :Earn points;
    :Update participant score;
  fork again
    :View leaderboard;
  fork end
endwhile (no - end date reached or manually ended)

|#LightBlue|Premium User Actions
:Complete competition;
:Set status to COMPLETED;
:Calculate final rankings;
:Announce winner;

stop
@enduml

FLOW DESCRIPTION:
1. Premium user creates competition with details
2. Competition created in PENDING status
3. Premium user starts the competition (ACTIVE)
4. Users join and participate
5. Progress tracked based on competition type
6. Leaderboard updated in real-time
7. Competition ends (date or manual)
8. Final rankings calculated, winner announced


================================================================================
3. STATE MACHINE DIAGRAMS (3 Most Important)
================================================================================

--------------------------------------------------------------------------------
STATE DIAGRAM 1. Competition States
--------------------------------------------------------------------------------

@startuml Competition_States
left to right direction
skinparam defaultFontSize 14
skinparam stateFontSize 14
skinparam arrowFontSize 14
scale 1400 width
[*] --> PENDING : Competition Created

PENDING --> ACTIVE : start()
PENDING --> CANCELLED : cancel()

ACTIVE --> COMPLETED : complete() or endDate reached
ACTIVE --> CANCELLED : cancel()

COMPLETED --> [*]
CANCELLED --> [*]

state PENDING {
  [*] --> WaitingToStart
  WaitingToStart : Competition created
  WaitingToStart : Participants can join
  WaitingToStart : Details can be edited
}

state ACTIVE {
  [*] --> InProgress
  InProgress --> TrackingProgress : participant action
  TrackingProgress --> InProgress : progress recorded

  InProgress : Competition is running
  InProgress : Participants earn progress
  InProgress : Leaderboard updated
  TrackingProgress : Recording participant action
}

state COMPLETED {
  [*] --> CalculatingResults
  CalculatingResults --> ResultsFinalized : rankings computed
  ResultsFinalized : Winner determined
  ResultsFinalized : Final leaderboard frozen
}

state CANCELLED {
  [*] --> Terminated
  Terminated : Competition ended prematurely
  Terminated : No winner declared
}
@enduml

STATE DESCRIPTIONS:
- PENDING: Competition created but not yet started. Users can join.
- ACTIVE: Competition in progress. Progress being tracked.
- COMPLETED: Competition finished. Rankings finalized.
- CANCELLED: Competition terminated before completion.

TRANSITIONS:
- PENDING -> ACTIVE: Premium user starts the competition
- PENDING -> CANCELLED: Premium user cancels before starting
- ACTIVE -> COMPLETED: End date reached or manually completed
- ACTIVE -> CANCELLED: Premium user cancels during competition

--------------------------------------------------------------------------------
STATE DIAGRAM 2. Task States
--------------------------------------------------------------------------------

@startuml Task_States
left to right direction
skinparam defaultFontSize 11
skinparam stateFontSize 11
skinparam arrowFontSize 10
scale 1400 width
[*] --> Created : Task created

Created --> Pending : assigned to user
Created --> Unassigned : no user assigned

Unassigned --> Pending : user assigned
Pending --> Overdue : dateToExecute passed
Pending --> Completed : user marks done
Overdue --> Completed : user marks done (late)

Completed --> Pending : user unchecks task

state Pending {
  [*] --> Scheduled
  Scheduled : Task has future date
  Scheduled --> DueToday : date matches today
  DueToday : Task is due today
}

state Completed {
  [*] --> Done
  Done : Task marked as completed
  Done : Points awarded to user
}

state Overdue {
  [*] --> PastDue
  PastDue : Execution date has passed
  PastDue : Task not completed
  PastDue : Visible in Overdue filter
}

Pending --> [*] : deleted
Overdue --> [*] : deleted
Completed --> [*] : deleted
@enduml

STATE DESCRIPTIONS:
- Created: Initial state when task is created
- Unassigned: Task exists but no user assigned
- Pending: Task assigned and waiting to be done
- Overdue: Task's due date has passed without completion
- Completed: Task marked as done

--------------------------------------------------------------------------------
STATE DIAGRAM 3. User Session States
--------------------------------------------------------------------------------

@startuml User_Session_States
left to right direction
skinparam defaultFontSize 11
skinparam stateFontSize 11
skinparam arrowFontSize 10
scale 1400 width
[*] --> Unauthenticated : App launched

Unauthenticated --> Authenticating : login attempt
Authenticating --> Authenticated : credentials valid
Authenticating --> Unauthenticated : credentials invalid

Authenticated --> TokenExpiring : token near expiration
TokenExpiring --> RefreshingToken : automatic refresh
RefreshingToken --> Authenticated : refresh successful
RefreshingToken --> Unauthenticated : refresh failed

Authenticated --> Unauthenticated : logout

state Authenticated {
  [*] --> Active
  Active --> Idle : no activity (timeout)
  Idle --> Active : user interaction

  Active : User actively using app
  Active : Full access to features
  Idle : App in background
  Idle : Session maintained
}

state Authenticating {
  [*] --> ValidatingCredentials
  ValidatingCredentials --> GeneratingTokens : valid
  GeneratingTokens --> StoringSession : tokens created
  ValidatingCredentials --> AuthFailed : invalid
}
@enduml

STATE DESCRIPTIONS:
- Unauthenticated: User not logged in
- Authenticating: Login in progress
- Authenticated: User has valid session
- TokenExpiring: JWT token approaching expiration
- RefreshingToken: Attempting to refresh token


================================================================================
4. SEQUENCE DIAGRAMS (3 Most Important)
================================================================================

--------------------------------------------------------------------------------
SEQUENCE DIAGRAM 1. User Login Process
--------------------------------------------------------------------------------

@startuml Login_Sequence
skinparam defaultFontSize 11
skinparam sequenceTitleFontSize 14
skinparam arrowFontSize 10
skinparam participantFontSize 11
scale 1400 width
actor User
participant "Flutter App" as App
participant "API Gateway\n:8099" as Gateway
participant "Auth Service\n:9020" as Auth
participant "Database Service\n:9009" as DB

User -> App : Enter credentials
App -> Gateway : POST /api_gateway/auth/login\n{username, password}
Gateway -> Auth : POST /api/auth/login\n{username, password}

Auth -> DB : GET /db/users/username/{username}
DB --> Auth : UserDTO

Auth -> Auth : Validate password\n(BCrypt compare)

alt Valid Credentials
    Auth -> Auth : Generate JWT access token
    Auth -> Auth : Generate refresh token
    Auth --> Gateway : AuthResponse\n{token, refreshToken, userId}
    Gateway --> App : AuthResponse
    App -> App : Store tokens in\nSecureStorage
    App -> Gateway : GET /api_gateway/users/{userId}
    Gateway -> DB : GET /db/users/{userId}
    DB --> Gateway : UserDTO
    Gateway --> App : UserDTO
    App -> App : Update AuthState\n(authenticated)
    App --> User : Navigate to Home Screen
else Invalid Credentials
    Auth --> Gateway : 401 Unauthorized
    Gateway --> App : Error Response
    App --> User : Display error message
end
@enduml

--------------------------------------------------------------------------------
SEQUENCE DIAGRAM 2. Task Completion with Points
--------------------------------------------------------------------------------

@startuml Task_Completion_Sequence
skinparam defaultFontSize 11
skinparam sequenceTitleFontSize 14
skinparam arrowFontSize 10
skinparam participantFontSize 11
scale 1400 width
actor User
participant "Flutter App" as App
participant "API Gateway\n:8099" as Gateway
participant "Task Service\n:9010" as Task
participant "Database Service\n:9009" as DB
participant "Competition Service\n:9011" as Comp

User -> App : Mark task as done
App -> Gateway : PUT /api_gateway/tasks/{taskId}\n{done: true}
Gateway -> Task : PUT /api/tasks/{taskId}
Task -> DB : PUT /db/tasks/{taskId}
DB -> DB : Update task record
DB --> Task : Updated TaskDTO

Task -> DB : GET /db/users/{userId}
DB --> Task : UserDTO (current points)

Task -> Task : Calculate new points\n(currentPoints + taskPoints)

Task -> DB : PUT /db/users/{userId}\n{pointsScore: newPoints}
DB --> Task : Updated UserDTO

Task --> Gateway : TaskDTO
Gateway --> App : TaskDTO

App -> Gateway : GET /api_gateway/competitions/active/{userId}
Gateway -> Comp : GET /api/competitions/active/{userId}
Comp -> DB : GET /db/competitions/participant/{userId}
DB --> Comp : List<CompetitionParticipant>

loop For each active competition
    Comp -> DB : PUT /db/competitions/participants/{id}\n{currentValue: updated}
    DB --> Comp : Updated participant
end

Comp --> Gateway : Updated competitions
Gateway --> App : Competition updates

App -> App : Update UI\n- Task marked done\n- Points updated\n- Competition progress
App --> User : Show success &\npoints notification
@enduml

--------------------------------------------------------------------------------
SEQUENCE DIAGRAM 3. Create and Join Competition
--------------------------------------------------------------------------------

@startuml Competition_Create_Join_Sequence
skinparam defaultFontSize 11
skinparam sequenceTitleFontSize 14
skinparam arrowFontSize 10
skinparam participantFontSize 11
scale 1400 width
actor "Premium User" as Premium
actor "Regular User" as RegUser
participant "Flutter App" as App
participant "API Gateway\n:8099" as Gateway
participant "Competition Service\n:9011" as Comp
participant "Database Service\n:9009" as DB

== Competition Creation ==
Premium -> App : Create competition form
App -> Gateway : POST /api_gateway/competitions\n{name, type, targetValue, dates, groupId}
Gateway -> Comp : POST /api/competitions
Comp -> DB : POST /db/competitions
DB -> DB : Create competition record\nStatus: PENDING
DB --> Comp : CompetitionDTO
Comp --> Gateway : CompetitionDTO
Gateway --> App : CompetitionDTO
App --> Premium : Show competition created

== Start Competition ==
Premium -> App : Start competition
App -> Gateway : PATCH /api_gateway/competitions/{id}/start
Gateway -> Comp : PATCH /api/competitions/{id}/start
Comp -> DB : PATCH /db/competitions/{id}\n{status: ACTIVE}
DB --> Comp : Updated CompetitionDTO
Comp --> Gateway : CompetitionDTO
Gateway --> App : Competition started
App --> Premium : Show competition active

== User Joins Competition ==
RegUser -> App : View available competitions
App -> Gateway : GET /api_gateway/competitions/group/{groupId}
Gateway -> Comp : GET /api/competitions/group/{groupId}
Comp -> DB : GET /db/competitions/group/{groupId}
DB --> Comp : List<CompetitionDTO>
Comp --> Gateway : Competitions
Gateway --> App : Competitions list
App --> RegUser : Display competitions

RegUser -> App : Join competition
App -> Gateway : PATCH /api_gateway/competitions/{id}/join\n{userId}
Gateway -> Comp : PATCH /api/competitions/{id}/join
Comp -> DB : POST /db/competitions/{id}/participants\n{userId, currentValue: 0}
DB --> Comp : CompetitionParticipantDTO
Comp --> Gateway : Updated competition
Gateway --> App : Join successful
App --> RegUser : Show joined competition

== View Leaderboard ==
RegUser -> App : View leaderboard
App -> Gateway : GET /api_gateway/competitions/{id}/leaderboard
Gateway -> Comp : GET /api/competitions/{id}/leaderboard
Comp -> DB : GET /db/competitions/{id}/participants
DB --> Comp : List<CompetitionParticipantDTO>\n(sorted by currentValue DESC)
Comp --> Gateway : Leaderboard
Gateway --> App : Participant rankings
App --> RegUser : Display leaderboard
@enduml


================================================================================
                          PART II: STRUCTURAL DIAGRAMS
================================================================================

================================================================================
5. CLASS DIAGRAMS (3 Total)
================================================================================

--------------------------------------------------------------------------------
CLASS DIAGRAM 1. Core Domain Models (Database Microservice)
--------------------------------------------------------------------------------

@startuml Domain_Classes
left to right direction
skinparam defaultFontSize 11
skinparam classFontSize 12
skinparam classAttributeFontSize 10
skinparam arrowFontSize 10
scale 1400 width

enum UserRole {
    USER
    ADMIN
    PREMIUM_USER
}

enum CompetitionStatus {
    PENDING
    ACTIVE
    COMPLETED
    CANCELLED
}

enum CompetitionType {
    POINTS
    TASKS_COMPLETED
    DISTANCE
    TIME
    CUSTOM
}

enum ListType {
    SHOPPING
    TODO
}

enum MealType {
    BREAKFAST
    LUNCH
    DINNER
    SNACK
}

class User {
    -Long id
    -String username
    -String password
    -String email
    -int pointsScore
    -UserRole role
    -Long groupId
    +getId(): Long
    +getUsername(): String
    +getPointsScore(): int
    +getRole(): UserRole
    +addPoints(int points): void
}

class UserGroup {
    -Long id
    -String name
    -String description
    -Long createdBy
    -String inviteCode
    -LocalDateTime createdAt
    +getId(): Long
    +getName(): String
    +getInviteCode(): String
    +regenerateInviteCode(): void
}

class Task {
    -Long id
    -String title
    -String description
    -LocalDate dateToExecute
    -boolean done
    -int pointsForCompletion
    -Long assignedToUserId
    -Long projectId
    +getId(): Long
    +markComplete(): void
    +isOverdue(): boolean
}

class Competition {
    -Long id
    -String name
    -String description
    -Long groupId
    -Long createdBy
    -CompetitionType competitionType
    -CompetitionStatus status
    -int targetValue
    -LocalDateTime startDate
    -LocalDateTime endDate
    -List<CompetitionParticipant> participants
    +start(): void
    +complete(): void
    +cancel(): void
    +addParticipant(User user): void
}

class CompetitionParticipant {
    -Long id
    -Long competitionId
    -Long userId
    -int currentValue
    -LocalDateTime joinedAt
    +updateProgress(int value): void
    +getCurrentValue(): int
}

class Lists {
    -Long id
    -String title
    -String description
    -Long groupId
    -Long createdBy
    -ListType listType
    -List<ListItem> items
    +addItem(ListItem item): void
    +getProgress(): double
}

class Recipe {
    -Long id
    -String title
    -String description
    -int prepTimeMinutes
    -int cookTimeMinutes
    -int servings
    -Long createdBy
    -Long groupId
    -List<RecipeIngredient> ingredients
    -List<RecipeStep> steps
    +getTotalTime(): int
}

class MealPlan {
    -Long id
    -String name
    -Long groupId
    -Long createdBy
    -LocalDate startDate
    -LocalDate endDate
    -List<MealPlanDay> days
    +getMealsForDate(LocalDate): List<MealPlanItem>
}

' Relationships
User "1" -- "0..1" UserGroup : belongs to
User "1" -- "*" Task : assigned to
User "1" -- "*" CompetitionParticipant : participates
UserGroup "1" -- "*" Competition : hosts
UserGroup "1" -- "*" Lists : owns
Competition "1" -- "*" CompetitionParticipant : has

@enduml

--------------------------------------------------------------------------------
CLASS DIAGRAM 2. Service Layer Architecture
--------------------------------------------------------------------------------

@startuml Service_Layer_Classes
left to right direction
skinparam defaultFontSize 11
skinparam classFontSize 12
skinparam classAttributeFontSize 10
skinparam arrowFontSize 10
scale 1400 width

abstract class AbstractRestService<T, ID> {
    #RestTemplate restTemplate
    #String baseUrl
    +findAll(): List<T>
    +findById(ID id): Optional<T>
    +save(T entity): T
    +deleteById(ID id): void
}

class UserService {
    +findByUsername(String username): Optional<User>
    +updatePoints(Long userId, int points): void
    +getUsersByGroup(Long groupId): List<User>
}

class TaskService {
    +findByUserId(Long userId): List<Task>
    +findByDate(LocalDate date): List<Task>
    +findOverdue(Long userId): List<Task>
    +markComplete(Long taskId): Task
}

class CompetitionService {
    +findByGroupId(Long groupId): List<Competition>
    +start(Long competitionId): Competition
    +complete(Long competitionId): Competition
    +join(Long competitionId, Long userId): void
    +getLeaderboard(Long competitionId): List<CompetitionParticipant>
}

class GroupService {
    +findByInviteCode(String inviteCode): Optional<UserGroup>
    +addMember(Long groupId, Long userId): void
    +removeMember(Long groupId, Long userId): void
    +regenerateInviteCode(Long groupId): UserGroup
}

class AuthService {
    -JwtUtil jwtUtil
    -PasswordEncoder passwordEncoder
    +register(RegisterRequest request): AuthResponse
    +login(LoginRequest request): AuthResponse
    +refreshToken(String refreshToken): AuthResponse
    +validateToken(String token): TokenValidationResponse
}

class JwtUtil {
    -String secretKey
    -long accessTokenExpiration
    +generateAccessToken(User user): String
    +generateRefreshToken(User user): String
    +validateToken(String token): boolean
    +extractUserId(String token): Long
}

AbstractRestService <|-- UserService
AbstractRestService <|-- TaskService
AbstractRestService <|-- CompetitionService
AbstractRestService <|-- GroupService

AuthService --> JwtUtil : uses

@enduml

--------------------------------------------------------------------------------
CLASS DIAGRAM 3. Flutter App Architecture (Simplified)
--------------------------------------------------------------------------------

@startuml Flutter_Architecture
left to right direction
skinparam defaultFontSize 11
skinparam classFontSize 12
skinparam classAttributeFontSize 10
skinparam arrowFontSize 10
scale 1400 width

abstract class BaseService {
    #Dio dio
    #String baseUrl
    #get<T>(String path): Future<Either<String, T>>
    #post<T>(String path, dynamic data): Future<Either<String, T>>
    #put<T>(String path, dynamic data): Future<Either<String, T>>
}

class AuthService {
    +login(String username, String password): Future<Either<String, AuthResponse>>
    +register(String username, String email, String password): Future<Either<String, AuthResponse>>
    +refreshToken(String refreshToken): Future<Either<String, AuthResponse>>
}

class TaskService {
    +list(): Future<Either<String, List<Task>>>
    +retrieve(int id): Future<Either<String, Task>>
    +save(Task task): Future<Either<String, Task>>
}

class CompetitionService {
    +list(): Future<Either<String, List<Competition>>>
    +join(int compId, int userId): Future<Either<String, bool>>
    +getLeaderboard(int compId): Future<Either<String, List<Participant>>>
}

class TokenStorageService {
    -FlutterSecureStorage storage
    +saveAuthData(AuthResponse response): Future<void>
    +getToken(): Future<String?>
    +clearAll(): Future<void>
}

abstract class StateNotifier<T> {
    #T state
}

class AuthNotifier {
    -AuthService authService
    -TokenStorageService tokenStorage
    +checkAuthStatus(): Future<void>
    +login(String username, String password): Future<void>
    +logout(): Future<void>
}

class AuthState {
    +AuthStatus status
    +String? username
    +int? userId
    +String? role
}

enum AuthStatus {
    initial
    loading
    authenticated
    unauthenticated
}

BaseService <|-- AuthService
BaseService <|-- TaskService
BaseService <|-- CompetitionService

StateNotifier <|-- AuthNotifier
AuthNotifier --> AuthService : uses
AuthNotifier --> TokenStorageService : uses
AuthNotifier --> AuthState : manages

@enduml


================================================================================
6. COMPONENT DIAGRAMS (3 Total)
================================================================================

--------------------------------------------------------------------------------
COMPONENT DIAGRAM 1. System Components Overview
--------------------------------------------------------------------------------

@startuml System_Components
left to right direction
skinparam defaultFontSize 11
skinparam componentFontSize 11
skinparam packageFontSize 12
skinparam arrowFontSize 10
scale 1400 width

package "Client Layer" {
    [Flutter Mobile App] as FlutterApp
}

package "API Layer" {
    [API Gateway :8099] as Gateway
}

package "Business Services Layer" {
    [Auth Service :9020] as Auth
    [Task Service :9010] as Task
    [Competition Service :9011] as Competition
    [User Service :9015] as UserSvc
    [Group Service :9021] as Group
    [List Service :9014] as List
    [Recipe Service :9022] as Recipe
    [MealPlan Service :9023] as MealPlan
    [Product Service :9019] as Product
    [Image Service :9024] as Image
}

package "Data Layer" {
    [Database Service :9009] as DBService
    database "MySQL\nHouseMateMicroservicesDB" as MySQL
    storage "MinIO\nObject Storage" as MinIO
}

' Client to Gateway
FlutterApp --> Gateway : HTTPS/REST

' Gateway to Services
Gateway --> Auth : HTTP
Gateway --> Task : HTTP
Gateway --> Competition : HTTP
Gateway --> UserSvc : HTTP
Gateway --> Group : HTTP
Gateway --> List : HTTP
Gateway --> Recipe : HTTP
Gateway --> MealPlan : HTTP
Gateway --> Product : HTTP
Gateway --> Image : HTTP

' Services to Database Service
Auth --> DBService : HTTP
Task --> DBService : HTTP
Competition --> DBService : HTTP
UserSvc --> DBService : HTTP
Group --> DBService : HTTP
List --> DBService : HTTP
Recipe --> DBService : HTTP
MealPlan --> DBService : HTTP
Product --> DBService : HTTP

' Image Service Special
Image --> DBService : HTTP (metadata)
Image --> MinIO : S3 API (files)

' Database Service to MySQL
DBService --> MySQL : JDBC

@enduml

--------------------------------------------------------------------------------
COMPONENT DIAGRAM 2. Microservice Internal Structure
--------------------------------------------------------------------------------

@startuml Microservice_Internal_Components
left to right direction
skinparam defaultFontSize 11
skinparam componentFontSize 11
skinparam packageFontSize 12
skinparam arrowFontSize 10
scale 1400 width

package "Competition Microservice" {
    component "Controller Layer" as CompCtrl {
        [CompetitionController]
    }

    component "Service Layer" as CompSvc {
        [CompetitionService]
    }

    component "Repository Layer" as CompRepo {
        [CompetitionRepository]
    }

    component "DTOs" as CompDTO {
        [CompetitionDTO]
        [CompetitionParticipantDTO]
    }

    CompCtrl --> CompSvc
    CompSvc --> CompRepo
    CompCtrl --> CompDTO
}

package "Database Microservice" {
    component "DB Controller Layer" as DBCtrl {
        [CompetitionController]
        [UserController]
        [TaskController]
    }

    component "DB Service Layer" as DBSvc {
        [CompetitionService]
        [UserService]
        [TaskService]
    }

    component "JPA Repository Layer" as DBRepo {
        [CompetitionRepository<<JpaRepository>>]
        [UserRepository<<JpaRepository>>]
        [TaskRepository<<JpaRepository>>]
    }

    DBCtrl --> DBSvc
    DBSvc --> DBRepo
}

package "External" {
    database "MySQL" as MySQL
}

CompRepo ..> DBCtrl : HTTP/REST
DBRepo --> MySQL : JPA/Hibernate

@enduml

--------------------------------------------------------------------------------
COMPONENT DIAGRAM 3. Flutter App Component Structure
--------------------------------------------------------------------------------

@startuml Flutter_App_Components
left to right direction
skinparam defaultFontSize 11
skinparam componentFontSize 11
skinparam packageFontSize 12
skinparam arrowFontSize 10
scale 1400 width

package "Flutter Application" {

    component "Presentation Layer" {
        [HomeScreen]
        [TaskListScreen]
        [CompetitionListScreen]
        [LoginScreen]
    }

    component "State Management" {
        [authProvider]
        [taskProvider]
        [competitionProvider]
        [AuthNotifier]
    }

    component "Data Layer" {
        [AuthService]
        [TaskService]
        [CompetitionService]
        [Models]
    }

    component "Core" {
        [BaseService]
        [TokenStorageService]
        [DioClient]
    }
}

[Presentation Layer] --> [State Management] : uses
[State Management] --> [Data Layer] : uses
[Data Layer] --> [Core] : extends/uses

@enduml


================================================================================
7. DEPLOYMENT DIAGRAMS (3 Total)
================================================================================

--------------------------------------------------------------------------------
DEPLOYMENT DIAGRAM 1. Production Environment
--------------------------------------------------------------------------------

@startuml Deployment_Diagram
left to right direction
skinparam defaultFontSize 11
skinparam nodeFontSize 11
skinparam componentFontSize 11
skinparam arrowFontSize 10
scale 1400 width

node "User Devices" {
    node "Android Phone" {
        component [Flutter App] as FlutterAndroid
    }
    node "iOS Phone" {
        component [Flutter App] as FlutteriOS
    }
}

cloud "Internet" as Internet

node "Docker Host Server" {
    node "Docker Network" {
        node "API Gateway Container" {
            component [API Gateway :8099] as Gateway
        }
        node "Auth Container" {
            component [Auth Service :9020] as Auth
        }
        node "Task Container" {
            component [Task Service :9010] as Task
        }
        node "Competition Container" {
            component [Competition Service :9011] as Competition
        }
        node "Database Service Container" {
            component [Database Service :9009] as DBService
        }
    }
    node "MySQL Container" {
        database "MySQL 8.0 :3306" as MySQL
    }
    node "MinIO Container" {
        storage "MinIO S3 :9000" as MinIO
    }
}

FlutterAndroid --> Internet
FlutteriOS --> Internet
Internet --> Gateway : "HTTPS :8099"

Gateway --> Auth
Gateway --> Task
Gateway --> Competition

Auth --> DBService
Task --> DBService
Competition --> DBService

DBService --> MySQL : "JDBC"
[Image Service :9024] --> MinIO : "S3 API"

@enduml

--------------------------------------------------------------------------------
DEPLOYMENT DIAGRAM 2. Docker Compose Configuration
--------------------------------------------------------------------------------

@startuml Docker_Compose_Deployment
left to right direction
skinparam defaultFontSize 11
skinparam nodeFontSize 11
skinparam componentFontSize 11
skinparam arrowFontSize 10
scale 1400 width

title Docker Compose Deployment Configuration

node "Docker Host" {

    package "docker-compose.yml" {

        node "my_mysql" <<container>> {
            component [MySQL 8.0]
            note right: Port: 3336:3306
        }

        node "minio" <<container>> {
            component [MinIO]
            note right: Port: 9000, 9001
        }

        node "dbmicroservice" <<container>> {
            component [Database Service]
            note right: Port: 9009
        }

        node "authmicroservice" <<container>> {
            component [Auth Service]
            note right: Port: 9020
        }

        node "api_gateway" <<container>> {
            component [API Gateway]
            note right: Port: 8099 (Entry point)
        }

        node "taskmicroservice" <<container>> {
            component [Task Service]
            note right: Port: 9010
        }

        node "competitionmicroservice" <<container>> {
            component [Competition Service]
            note right: Port: 9011
        }
    }

    package "Docker Volumes" {
        storage "mysql_data"
        storage "minio_data"
    }

    package "Docker Network" {
        cloud "my_custom_microservices_network (bridge)"
    }
}

@enduml

--------------------------------------------------------------------------------
DEPLOYMENT DIAGRAM 3. Network Communication
--------------------------------------------------------------------------------

@startuml Network_Communication
left to right direction
skinparam defaultFontSize 11
skinparam nodeFontSize 11
skinparam componentFontSize 11
skinparam arrowFontSize 10
scale 1400 width

title Network Communication Architecture

cloud "External Network" {
    actor "Mobile User" as User
}

frame "Docker Network: my_custom_microservices_network" {

    rectangle "Entry Point" {
        node "API Gateway\n:8099" as Gateway
    }

    rectangle "Authentication" {
        node "Auth Service\n:9020" as Auth
    }

    rectangle "Core Business Services" {
        node "Task :9010" as Task
        node "Competition :9011" as Comp
        node "User :9015" as UserSvc
        node "Group :9021" as Group
    }

    rectangle "Data Persistence" {
        node "Database Service\n:9009" as DBSvc
        database "MySQL :3306" as MySQL
        storage "MinIO :9000" as MinIO
    }
}

User --> Gateway : "HTTPS :8099"

Gateway --> Auth : "HTTP (internal)"
Gateway --> Task : "HTTP (internal)"
Gateway --> Comp : "HTTP (internal)"
Gateway --> UserSvc : "HTTP (internal)"
Gateway --> Group : "HTTP (internal)"

Auth --> DBSvc
Task --> DBSvc
Comp --> DBSvc
UserSvc --> DBSvc
Group --> DBSvc

DBSvc --> MySQL : "JDBC"
[Image Service] --> MinIO : "S3"

note bottom of Gateway
    JWT Authentication Filter
    validates all requests
end note

@enduml


================================================================================
                              END OF DOCUMENT
================================================================================
